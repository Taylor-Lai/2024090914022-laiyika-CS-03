# 2024090914022-赖伊卡-CS-03
## C语言内存模型
### 概念理解
#### 1,程序代码区
具体含义：程序代码区存放了程序的可执行代码，包括函数、指令等。这部分内存是只读的，防止程序运行时被意外修改。

应用场景：当程序被加载到内存中时，其可执行代码被放置在代码区。CPU通过执行这些代码来执行程序的功能。

调用方式：程序代码区的执行不需要显式调用，而是由操作系统或程序自身的执行流程自动执行。程序中的函数调用会导致CPU跳转到代码区的相应位置执行。

#### 2,常量区
具体含义： 常量区用于存储程序中定义的常量值，如字符串常量、数字常量等。这些值在程序运行期间不会改变。

应用场景： 常量区常用于存储全局常量，这些常量在程序的多个部分中被引用，但不允许被修改。例如，配置信息、错误代码等。

调用方式： 常量区的访问通常通过变量名或常量名进行，编译器在编译时会将常量名替换为对应的常量值。

#### 3,全局数据区
具体含义： 全局数据区用于存储全局变量和静态变量。这些变量在程序的整个运行期间都存在，并且对所有函数都是可见的。

应用场景： 全局数据区常用于存储需要在程序多个部分之间共享的数据。例如，配置文件中的参数、程序的运行状态等。

调用方式： 全局数据区的变量可以通过变量名直接访问，无需特殊调用方式。

#### 4,堆区
具体含义： 堆区是程序运行时用于动态分配内存的区域。与栈区不同，堆区的内存分配和释放由程序员手动控制（通过如malloc、free等函数）。

应用场景： 堆区适用于存储大小不确定或生命周期与程序运行时间相同的数据。例如，动态数组、链表、树等数据结构。

调用方式： 堆区的内存分配通常使用如malloc、calloc、realloc等函数，释放则使用free函数。

#### 5,动态链接库
具体含义： 动态链接库是一种包含可被多个程序同时使用的代码和数据的文件。与静态链接库不同，动态链接库在程序运行时才被加载到内存中。

应用场景： 动态链接库常用于实现代码的共享和重用，减少程序的大小和提高内存的使用效率。例如，操作系统的API、图形库、数据库驱动等常以动态链接库的形式提供。

调用方式： 在Windows系统中，动态链接库的调用可以通过隐式链接（通过.lib文件和.h头文件）或显式链接（使用LoadLibrary和GetProcAddress函数）来实现。

#### 6,栈区
具体含义： 栈区是程序运行时用于存储局部变量、函数参数和返回地址等数据的区域。栈区遵循后进先出（LIFO）的原则。

应用场景： 栈区主要用于函数调用的过程中，存储函数的局部变量、参数和返回地址等信息。每次函数调用时，都会在栈上分配一块内存用于存储这些信息，函数返回时则释放这块内存。

调用方式： 栈区的使用由编译器自动管理，程序员无需显式调用。函数调用和返回时，编译器会自动在栈上分配和释放内存。

### 导学模型
#### 1. 
  指程序在运行过程中，由于栈空间的使用超过了其分配的大小，导致数据溢出到其他内存区域。这种情况通常会导致程序崩溃，甚至可能被恶意利用来执行未授权的代码。
#### 2.
      1,内存分配与释放
      栈区：由操作系统自动分配和释放，存放函数的参数值、局部变量的值等。在函数调用时，系统为这些局部变量在栈上分配空间，函数返回时，系统自动释放这些空间。
      堆区：一般由程序员手动申请分配和释放。程序员使用如malloc、new等函数或操作符在堆上申请空间，使用完毕后需通过free、delete等函数或操作符手动释放空间。若程序员不释放，程序结束时可能由操作系统回收。

      2,内存大小和空间
      栈区：栈的大小系统预先规定好的，空间相对较小。在Windows下，栈的大小通常是2MB（也有说法是1MB），这是一个编译时就确定的常数。如果申请的空间超过栈的剩余空间，将提示栈溢出。
      堆区：堆的大小受限于计算机系统中有效的虚拟内存，空间相对较大，且比较灵活。堆申请的内存是一块不连续的内存区域，这是由于系统使用链表来存储空闲内存地址。
  
      3,数据结构和存取方式
      栈区：栈是一种先进后出（LIFO）的数据结构，只允许在栈顶进行插入（push）和删除（pop）操作。栈中的数据在内存中是一块连续的区域。
      堆区：堆虽然也常被看作是一种树形数据结构（如堆排序中的堆），但在内存管理中，堆更多是指一种动态分配内存的方式。堆中的数据在内存中是不连续的区域，由链表等数据结构管理。
   
      4,缓存与访问速度
      栈区：栈使用的是一级缓存，调用速度较快。栈中的数据在调用时通常处于存储空间中，调用完毕后立即释放。
      堆区：堆是存放在二级缓存中的，生命周期由虚拟机的垃圾回收算法来决定。因此，调用堆中对象的速度相对较慢。
   
      5,碎片与内存管理
      栈区：栈不会产生内存碎片，因为它是连续分配的内存区域。
      堆区：堆由于采用链表等数据结构管理内存，容易产生内存碎片。碎片是分配出去但未被使用的内存空间，它们虽然存在但无法被有效利用。
   
      6,应用场景
      栈区：适用于存储局部变量、函数参数等生命周期较短的数据。由于栈的自动分配和释放特性，以及LIFO的存取方式，栈在函数调用、递归算法等场景中有着广泛的应用。
      堆区：适用于存储生命周期较长或大小不确定的数据，如动态数组、链表、树等数据结构。堆的灵活性使得它成为实现这些数据结构的重要选择。
  #### 3.
  只读区域有程序代码区，常量区。
  
  可读写区域有全家数据区，堆区，动态链接库和栈区。
  #### 4.
  malloc可以动态分配内存，原型为void* malloc(size_t size)。也就是括号里给定你要开辟的内存大小，前面用指针变量接收就可以了。
  
  free则是用来释放掉malloc分配的内存块，原型是void free(void* ptr);也就是直接在括号里给出要释放空间的地址就行。
  
  他俩都是在堆区上进行操作的。
  #### 5.
      1，避免内存泄露，内存管理可以及时释放不再使用的内存，防止内存泄漏的发生。
      2，提高内存使用效率，内存管理可以优化内存空间的使用更高效的利用有限的内存空间。
      3，提高程序的执行速度，内存管理可以避免内存之间发生冲突，从而使程序可以更加高效的进行。
      4，保证程序的安全与稳定，防止诸如野指针，越界访问等导致程序崩溃或者故障。

      
## 内存模型的运用
